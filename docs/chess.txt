package chessboard //klasy z pakietu nie korzystają z innych klas

klasa Chessboard{ //zrobić aby logika gry wykorzystywała z tego pakietu tylko Chessboard
	Place[8][8] chessboard
	List<Figure> figures
   	StateOfChessboard stateOfChessboard

	getPlaceByCoordinates(char crX, int crY) : Place
	getFigureByCoordinates(char crX, int crY) : Figure
	setChessboardByArrangement(Arrangement arrangement)
	updateMove(Move move)
	updateBackMove()
}

klasa Place{
	char final coordinateX
	int final coordinateY
	Figure currentFigure
}
	
Klasa Figure{
	TypeOfFigure final type
	Color final color
	boolean isMoved
	boolean isBeaten
}

Enum Color{
	black,
	white
}

Enum TypeOfFigure{
	pawn(" "),
	knight("N"),
	bishop("B"),
	rook("R"),
	queen("Q"),
	king("K")
}


package status

klasa StateOfChessboard{
	Arrangement startedArrangement //tworzony w konstruktorze
	List<Arrangement> historyOfArrangement
	List<Move> historyOfMoves

	createStartedArrangement() : Arrangement
	addNewMove(Move move) : Arrangement
	backMove() : Arrangement
	getMoveBuilder() : moveBuilder
}

Klasa Arrangement{
	Map<String, Figure>	figuresArrangement

	getFigure(String place) : Figure
	createArrangement()
	createArrangement(Arrangement startedArrangement, List<Move> historyOfMoves)
	createArrangement(Arrangement lastArrangement, Move move)
}

klasa Move{ //wykorzystać builder
	Color final currentPlayerColor
	Figure final movedFigure
	Figure final beatenFigure //domyslnie null
	Place final previousPlace
	Place final nextPlace
	typeOfMove final typeOfMove //domyslnie normal

	klasa MoveBuilder
}

enum TypeOfCustomMove{
    normal,
    longcastle
    shortcastle
    enpassant
    pawntransform
}

//pomyśleć o enumie oznaczającym inne symbole ruchu jak bicie, szacha itp

//logika apdejtowania ruchu:
//  1. gameManager -> createMove()
//  2. gameManager -> makeMove()
//  3. gameManager -> chessboard.updateMove(move)
//  4. chessboard -> statusOfChessboard.addMove(move)
//  5. chessboard -> statusOfChessboard.getNewArrangement()
//  6. chessboard -> setChessboardByArrangement(arrangement)


package logic

klasa MovesValidator{
	static getAllPlacesAttackedByFigure(Chessboard chessboard, Figure figure) : List<Place>
	static getAllCorrectMovePlacesByFigure(Chessboard chessboard, Figure figure) : List<Place>
	static isCorrectMove(Chessboard chessboard, Move testedMove) : boolean
	static isAttackedPlace(Chessboard chessboard, Place place) : boolean
}

klasa GameResultValidator{
	static isCheck(Chessboard chessboard, Color movedPlayer) : boolean
	static isCheckmate(Chessboard chessboard, Color movedPlayer) : boolean
	static isStalemate(Chessboard chessboard, Color movedPlayer) : boolean
}

Klasa CustomMovesValidator{
    static isEnPassantCorrect(Chessboard chessboard, Figure movedFigure, Move previousMove) : boolean
    static isCastleShortCorrect(Chessboard chessboard, Figure movedFigure)
    static isCastleLongCorrect(Chessboard chessboard, Figure movedFigure)
}


package player

klasa Player{
	String nickName
	String password
	int rating
	int numberOfWinMatches
	int numberOfLostMatches
	List<StateOfChessboard> savedMatches
	
	updateRating()
	updateWin()
	updateLost()
	addTheMatch()
}

klasa computerPlayer{
	// pokminić
}


package manager

klasa GameManager{
	Chessboard chessboard
	Player whitePlayer
	Player blackPlayer
	Color currentPlayer	
	MoveBuilder createdMove
	
	checkPlace(String clickedPlace) : List<Place> {
		// sprawdzić trzy możliwości
			// 1. pole wybrane pierwszy raz, posiadające figure w odpowiednim kolorze, wtedy zwrócić listę pól, na które może pójść
			// 2. drugi raz wybrane to samo pole, wtedy trzeba wyłączyć kliknięcie (zwrócić pustą listę)
			// 3. kliknięcie w pole należące do listy z kroku 1., wtedy należy stworzyć createdMove i wywolać metodę makeMove() i zwrócić pustą listę 
	
		List<Place> listPlace GameLogic.getAllCorrectMovePlacesByFigure(chessboard, chessboard.getFigureWithCoordinates(/*choosenPlace*/))
	}
	
	makeMove() : StateOfMatch {
		// logika robienia ruchu, uaktualnienia stanu szachownicy (chessboard i arrangement), dodanie ruchu do historii itp
		// logika sprawdzania stanu partii i zwrócenie rezultatu (metody z GameLogic)
	}
	
	backMove() {
		// logika cofania ruchu, uaktualniania stanu szachownicy, usuwanie ruchu z historii itp
	}
	
	
}

enum StateOfMatch{
	gameIsNotFinished,
	check,
	whiteIsWinner,
	blackIsWinner,
	stalemate
}

package gui
GameManagerGUIAdapter









